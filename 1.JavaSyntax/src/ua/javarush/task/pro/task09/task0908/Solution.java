package ua.javarush.task.pro.task09.task0908;

import java.util.regex.Pattern;

/* 
Двійково-шістнадцятковий конвертер
Публічний статичний метод toHex(String) має перетворювати рядкове подання двійкового числа, отримане як вхідний
параметр, з двійкової системи числення в шістнадцяткову й повертати його рядкове подання. А публічний статичний
метод toBinary(String) навпаки — має перетворювати рядкове подання шістнадцяткового числа на рядкове подання
двійкового числа.

Методи діють тільки для непорожніх рядків.
Якщо вхідний параметр — порожній рядок або null, обидва методи повертають порожній рядок.
Якщо вхідний параметр методу toHex(String) містить символи, відмінні від 0 і 1, метод повертає порожній рядок.
Якщо вхідний параметр методу toBinary(String) містить символи, крім цифр 0–9 і малих латинських літер a–f, метод
повертає порожній рядок.

Твоє завдання — реалізувати ці методи.

Нижче наведено один із алгоритмів перетворення рядкового подання двійкового числа на рядкове подання
шістнадцяткового числа.

Перевіряємо довжину рядка, отриманого як вхідний параметр. Вона має бути кратною 4.
Якщо це не так, слід додати на початку рядка потрібну кількість цифр 0.
По черзі перевіряємо кожні чотири символи (біти) на відповідність певному символу шістнадцяткового кодування.
Приклад:

двійкове подання — "100111010000", де "1001" — "9", "1101" — "d", "0000" — "0",
шістнадцяткове подання — "9d0".
Нижче наведено один із алгоритмів перетворення рядкового подання шістнадцяткового числа на рядкове подання
двійкового числа.
По черзі перевіряємо кожний символ на відповідність двійковому числу (4 біти).

Приклад:

шістнадцяткове подання — "9d0", де "9" — "1001", "d" — "1101", "0" — "0000",
двійкове подання — "100111010000".
Метод main() у тестуванні не використовується.


Requirements:
1. Потрібно реалізувати метод toHex(String) згідно з умовою.
2. Потрібно реалізувати метод toBinary(String) згідно з умовою.
3. Методи Integer.toBinaryString(int) і Long.toBinaryString(int) використовувати не можна.
4. Методи Integer.toHexString(int) і Long.toHexString(int) використовувати не можна.
5. Методи Integer.parseInt(String, int) і Long.parseLong(String, int) використовувати не можна.
6. Методи Integer.toString(int, int) і Long.toString(long, int) використовувати не можна.
7. Об'єкт типу BigInteger використовувати не можна.
8. Об'єкт типу BigDecimal використовувати не можна.
*/

public class Solution {

    public static void main(String[] args) {
        String binaryNumber = "100111010000";
        System.out.println("Двійкове число " + binaryNumber + " дорівнює шістнадцятковому числу " + toHex(binaryNumber));
        String hexNumber = "9d0";
        System.out.println("Шістнадцяткове число " + hexNumber + " дорівнює двійковому числу " + toBinary(hexNumber));
    }

    public static String toHex(String binaryNumber) {
        //напишіть тут ваш код
        String HEX = "0123456789abcdef";

        if (binaryNumber == null || binaryNumber.isEmpty()) {
            return "";
        }

        while (binaryNumber.length() % 4 != 0) {
            binaryNumber = "0" + binaryNumber;
        }

        StringBuilder hexNumber = new StringBuilder();

        for (int i = 0; i < binaryNumber.length(); i += 4) {
            String group = binaryNumber.substring(i, i + 4);
            int decimalGroup = 0;
            for (int j = 0; j < group.length(); j++) {
                decimalGroup = decimalGroup * 2 + (group.charAt(j) - '0');
            }
            hexNumber.append(HEX.charAt(decimalGroup));
        }

        return hexNumber.toString();
    }

    public static String toBinary(String hexNumber) {
        //напишіть тут ваш код
        String HEX = "0123456789abcdef";

        if (hexNumber == null || hexNumber.isEmpty()) {
            return "";
        }

        StringBuilder binary = new StringBuilder();
        for (int i = 0; i < hexNumber.length(); i++) {
            char hexChar = hexNumber.charAt(i);
            int decimalValue = HEX.indexOf(hexChar);

            if (decimalValue == -1) {
                return "";
            }

            for (int j = 3; j >= 0; j--) {
                binary.append((decimalValue >> j) & 1);
            }
        }
        return binary.toString();
    }
}

/*
Розглянемо детально, як наш метод toHex(String) працює на прикладі двійкового числа "100111010000".

Спочатку перевіряємо, чи двійкове число кратне 4. У нашому випадку число вже кратне 4, тому нічого не додаємо.

Рядок binaryNumber: "100111010000"

Тепер перебираємо двійковий рядок, витягуючи групи по 4 символи (біти) та перетворюємо їх у відповідні
шістнадцяткові символи.

i. Перша група: "1001"

Перетворюємо "1001" у десяткове число (9) таким чином:
decimalGroup = 0 * 2 + 1 = 1
decimalGroup = 1 * 2 + 0 = 2
decimalGroup = 2 * 2 + 0 = 4
decimalGroup = 4 * 2 + 1 = 9

Знаходимо відповідний символ у рядку HEX: "9"

ii. Друга група: "1101"

Перетворюємо "1101" у десяткове число (13) таким чином:
decimalGroup = 0 * 2 + 1 = 1
decimalGroup = 1 * 2 + 1 = 3
decimalGroup = 3 * 2 + 0 = 6
decimalGroup = 6 * 2 + 1 = 13

Знаходимо відповідний символ у рядку HEX: "d"

iii. Третя група: "0000"

Перетворюємо "0000" у десяткове число (0) таким чином:
decimalGroup = 0 * 2 + 0 = 0
decimalGroup = 0 * 2 + 0 = 0
decimalGroup = 0 * 2 + 0 = 0
decimalGroup = 0 * 2 + 0 = 0

Знаходимо відповідний символ у рядку HEX: "0"

З'єднуємо отримані шістнадцяткові символи: "9d0"

Отже, двійкове число "100111010000" дорівнює шістнадцятковому числу "9d0".

*********************************************************************************************************************

розглянемо детальніше ітерації та роботу методів для кожного кроку на прикладі двійкового числа "100111010000":

Проходимо через двійковий рядок, витягуючи групи по 4 символи (біти) та перетворюємо їх у відповідні
шістнадцяткові символи:

i. Перша група:

Виконуємо String group = binaryNumber.substring(i, i + 4);
i = 0, отже, binaryNumber.substring(0, 4) відтворює підрядок "1001"

Розрахунок decimalGroup для "1001" виконується в циклі (як вище описано), отримуємо decimalGroup = 9

Виконуємо hexNumber.append(HEX.charAt(decimalGroup));
HEX: "0123456789abcdef"
HEX.charAt(9) повертає символ '9', тому hexNumber стає "9"

ii. Друга група:

Виконуємо String group = binaryNumber.substring(i, i + 4);
i = 4, отже, binaryNumber.substring(4, 8) відтворює підрядок "1101"

Розрахунок decimalGroup для "1101" виконується в циклі (як вище описано), отримуємо decimalGroup = 13

Виконуємо hexNumber.append(HEX.charAt(decimalGroup));
HEX: "0123456789abcdef"
HEX.charAt(13) повертає символ 'd', тому hexNumber стає "9d"

iii. Третя група:

Виконуємо String group = binaryNumber.substring(i, i + 4);
i = 8, отже, binaryNumber.substring(8, 12) відтворює підрядок "0000"

Розрахунок decimalGroup для "0000" виконується в циклі (як вище описано), отримуємо decimalGroup = 0

Виконуємо hexNumber.append(HEX.charAt(decimalGroup));
HEX: "0123456789abcdef"
HEX.charAt(0) повертає символ '0', тому hexNumber стає "9d0"

Повертаємо отриманий рядок hexNumber: "9d0"

Отже, двійкове число "100111010000" дорівнює шістнадцятковому числу "9d0


*********************************************************************************************************************
*********************************************************************************************************************
*********************************************************************************************************************

розглянемо детальніше ітерації та роботу методів для кожного кроку на прикладі шістнадцяткового числа "9d0":

Проходимо через шістнадцятковий рядок, перетворюючи кожен символ у відповідні двійкові значення:

i. Перший символ '9':

Виконуємо char hexChar = hexNumber.charAt(i);
i = 0, отже, hexNumber.charAt(0) повертає символ '9'

Виконуємо int decimalValue = HEX.indexOf(hexChar);
HEX: "0123456789abcdef", HEX.indexOf('9') повертає 9 (decimalValue = 9)

Виконуємо цикл for (int j = 3; j >= 0; j--):
j=3: binary.append((9 >> 3) & 1); // 1001 >> 3 = 0001, 0001 & 0001 = 0001 (1)
j=2: binary.append((9 >> 2) & 1); // 1001 >> 2 = 0010, 0010 & 0001 = 0000 (0)
j=1: binary.append((9 >> 1) & 1); // 1001 >> 1 = 0100, 0100 & 0001 = 0000 (0)
j=0: binary.append((9 >> 0) & 1); // 1001 >> 0 = 1001, 1001 & 0001 = 0001 (1)

Отримали двійковий рядок "1001" для символа '9'

ii. Другий символ 'd':

Виконуємо char hexChar = hexNumber.charAt(i);
i = 1, отже, hexNumber.charAt(1) повертає символ 'd'

Виконуємо int decimalValue = HEX.indexOf(hexChar);
HEX: "0123456789abcdef", HEX.indexOf('d') повертає 13 (decimalValue = 13)

Виконуємо цикл for (int j = 3; j >= 0; j--):
j=3: binary.append((13 >> 3) & 1); // 1101 >> 3 = 0001, 0001 & 0001 = 0001 (1)
j=2: binary.append((13 >> 2) & 1); // 1101 >> 2 = 0011, 0011 & 0001 = 0001 (1)
j=1: binary.append((13 >> 1) & 1); // 1101 >> 1 = 0110, 0110 & 0001 = 0000 (0)
j=0: binary.append((13 >> 0) & 1); // 1101 >> 0 = 1101, 1101 & 0001 = 0001 (1)

Отримали двійковий рядок "1101" для символа 'd'
Додаємо його до нашого двійкового числа: "1001" + "1101" = "10011101"

iii. Третій символ '0':

Виконуємо char hexChar = hexNumber.charAt(i);
i = 2, отже, hexNumber.charAt(2) повертає символ '0'

Виконуємо int decimalValue = HEX.indexOf(hexChar);
HEX: "0123456789abcdef", HEX.indexOf('0') повертає 0 (decimalValue = 0)

Виконуємо цикл for (int j = 3; j >= 0; j--):
j=3: binary.append((0 >> 3) & 1); // 0000 >> 3 = 0000, 0000 & 0001 = 0000 (0)
j=2: binary.append((0 >> 2) & 1); // 0000 >> 2 = 0000, 0000 & 0001 = 0000 (0)
j=1: binary.append((0 >> 1) & 1); // 0000 >> 1 = 0000, 0000 & 0001 = 0000 (0)
j=0: binary.append((0 >> 0) & 1); // 0000 >> 0 = 0000, 0000 & 0001 = 0000 (0)

Отримали двійковий рядок "0000" для символа '0'
Додаємо його до нашого двійкового числа: "10011101" + "0000" = "100111010000"

Повертаємо отриманий рядок binary: "100111010000"
Отже, шістнадцяткове число "9d0" дорівнює двійковому числу "100111010000".

*********************************************************************************************************************

Вираз binary.append((decimalValue >> j) & 1) використовується для отримання двійкового представлення decimalValue.
Давайте розіб'ємо його на частини:

decimalValue >> j - це операція зсуву вправо на j позицій. Вона зміщує біти числа decimalValue вправо на задану
кількість позицій. Наприклад, якщо decimalValue дорівнює 9 (1001 у двійковій формі), то:

при j = 3: 1001 >> 3 = 0001
при j = 2: 1001 >> 2 = 0010
при j = 1: 1001 >> 1 = 0100
при j = 0: 1001 >> 0 = 1001
(decimalValue >> j) & 1 - це операція логічного "і" (&) між результатом зсуву вправо (decimalValue >> j)
та числом 1 (0001 у двійковій формі). Вона дозволяє визначити значення останнього біта (справа) в результаті
зсуву вправо:

при j = 3: (1001 >> 3) & 1 = 0001 & 0001 = 0001 (1)
при j = 2: (1001 >> 2) & 1 = 0010 & 0001 = 0000 (0)
при j = 1: (1001 >> 1) & 1 = 0100 & 0001 = 0000 (0)
при j = 0: (1001 >> 0) & 1 = 1001 & 0001 = 0001 (1)
binary.append((decimalValue >> j) & 1) - додаємо результат логічного "і" до рядка binary. Це рядок,
який містить двійкове представлення шістнадцяткового числа:

при j = 3: binary.append(1); // binary = "1"
при j = 2: binary.append(0); // binary = "10"
при j = 1: binary.append(0); // binary = "100"
при j = 0: binary.append(1); // binary = "1001"
Отже, для символу '9' ми отримали двійковий рядок "1001".


Давайте спочатку розберемося з перетворенням шістнадцяткового числа 9 в двійкове представлення.

Шістнадцяткове число 9 відповідає двійковому числу 1001. Це можна знайти, використовуючи таблицю перетворення
шістнадцяткових чисел у двійкові:

0 - 0000
1 - 0001
2 - 0010
3 - 0011
4 - 0100
5 - 0101
6 - 0110
7 - 0111
8 - 1000
9 - 1001
A - 1010
B - 1011
C - 1100
D - 1101
E - 1110
F - 1111
З таблиці ми бачимо, що 9 (шістнадцяткове) відповідає 1001 (двійкове).

Тепер розглянемо операцію зсуву вправо. Коли ми зміщуємо біти числа вправо, ми "відрізаємо" біти справа
на вказану кількість позицій. Наприклад, якщо ми маємо число 1001 і зсуваємо його вправо на 3 позиції, ми
отримаємо 0001, оскільки ми "відрізали" 3 правих біти (100).

Цикл for (int j = 3; j >= 0; j--) використовується для того, щоб пройтися по кожному біту числа, яке ми
хочемо перетворити у двійкове представлення. У нашому випадку ми хочемо перетворити 4-бітне число, тому ми
починаємо з 3 (найвищий індекс) і зменшуємо його на 1 кожного разу, поки не дійдемо до 0 (найнижчий індекс).

Операція & 1 використовується для визначення значення останнього біта (справа) в результаті зсуву вправо.
Операція логічного "і" (&) порівнює кожен біт двох чисел, і якщо обидва біти дорівнюють 1, то результат також буде 1.

У нашому випадку ми використовуємо операцію логічного "і" (&) з числом 1, що допомагає нам визначити значення
останнього біта (справа) після зсуву вправо.

Таким чином, коли ми виконуємо операцію (decimalValue >> j) & 1, ми отримуємо значення біта, який знаходиться
на позиції j від значення decimalValue. Це дає нам можливість відтворити двійкове представлення шістнадцяткового числа.

Для прикладу, коли decimalValue дорівнює 9, ми отримуємо наступні результати:

j=3: (9 >> 3) & 1 => 0001 & 0001 = 0001 (1)
j=2: (9 >> 2) & 1 => 0010 & 0001 = 0000 (0)
j=1: (9 >> 1) & 1 => 0100 & 0001 = 0000 (0)
j=0: (9 >> 0) & 1 => 1001 & 0001 = 0001 (1)
Значення, отримані на кожному кроці, конкатенуються у рядок binary і формують двійкове представлення шістнадцяткового
числа, у даному випадку "1001".

детальніше пояснення процесу зсуву вправо на 3 біти для числа 1001:

Оригінальне число: 1001 (9 у десятковій формі)
Зсув на 1 біт вправо: 0100 (4 у десятковій формі)
Зсув на 2 біти вправо: 0010 (2 у десятковій формі)
Зсув на 3 біти вправо: 0001 (1 у десятковій формі)
Під час зсуву вправо на 3 біти, кожен біт числа зміщується вправо на 3 позиції. Зліва вводяться додаткові нулі,
якщо потрібно, щоб довжина двійкового числа збереглася. З кожним кроком зсуву вправо кожен біт зміщується на одну
позицію вправо, і зліва доповнюються нулями.

В результаті зсуву на 3 біти вправо, отримуємо число 0001.

Логічна операція "і" (&) - це побітова операція, яка працює на рівні бітів числа. Вона не є множенням або додаванням,
але порівнює кожен біт двох чисел, і якщо обидва біти дорівнюють 1, то результатом цієї операції для цього біта
буде 1, в іншому випадку - 0.

Використання логічної операції "і" з числом 1 (0001 у двійковій формі) дає нам змогу визначити значення останнього
біта числа (справа). Це працює, тому що при виконанні операції "і" з 1, всі біти, крім останнього, будуть завжди
дорівнювати 0 (через співпадіння з відповідними бітами числа 1, які дорівнюють 0).

Тут як працює операція & для прикладу j=3:

  0001 (1)          1. bit: 0 & 0 = 0
& 0001 (1)          2. bit: 0 & 0 = 0
  ----             3. bit: 0 & 0 = 0
  0001 (1)          4. bit: 1 & 1 = 1
Оскільки цікавить нас лише останній біт, ми розглядаємо лише 4-й рядок з результатами порівняння (1 & 1 = 1). Значення
інших бітів результату неважливі для нашої мети, оскільки вони завжди дорівнюють 0.

Вираз (decimalValue >> j) & 1 використовується для отримання значення певного біта в числі decimalValue. У нашому
випадку метою є конвертація шістнадцяткового числа в двійкове, тому ми хочемо отримати кожен біт окремо. Шістнадцяткове
число може бути представлене як 4-бітове двійкове число, тому нам потрібно дізнатися значення кожного з цих 4-х бітів.

Зсув вправо на j позицій (decimalValue >> j) дає нам можливість отримати значення потрібного біта. В процесі ітерацій
ми зсуваємо decimalValue на 3, 2, 1 та 0 позицій вправо, щоб отримати значення кожного з 4-х бітів.

Після зсуву вправо ми виконуємо операцію логічного "і" (&) з числом 1, щоб дізнатися значення останнього біта (справа)
зсунутого числа. Це дає нам можливість отримати значення кожного біта почергово.

Таким чином, ми не беремо лише останній біт decimalValue, а отримуємо значення кожного з 4-х бітів послідовно,
використовуючи зсув вправо на j позицій та операцію логічного "і" (&) з числом 1.

*********************************************************************************************************************

Побітові операції виконуються на рівні окремих бітів чисел. Ось основні правила виконання побітових операцій:

1) Побітове І (AND) &:

1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0
Ця операція порівнює кожен біт першого числа з відповідним бітом другого числа. Якщо обидва біти дорівнюють 1,
результатом буде 1. В іншому випадку результатом буде 0.


2) Побітове виключне АБО (XOR) ^:

1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
Ця операція порівнює кожен біт першого числа з відповідним бітом другого числа. Якщо біти різні (один дорівнює 1,
а другий - 0), результатом буде 1. В іншому випадку результатом буде 0.


3) Побітове включне АБО (OR) |:

1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0
Ця операція порівнює кожен біт першого числа з відповідним бітом другого числа. Якщо хоча б один з бітів дорівнює 1,
результатом буде 1. Якщо обидва біти дорівнюють 0, результатом буде 0.


Кожна з цих операцій виконується на рівні окремих бітів, тому перед виконанням операцій числа розкладаються на двійкові
представлення. Потім кожен біт першого числа порівнюється з відповідним бітом другого числа, і отримується результат
для кожної пари бітів. Після завершення операції результат знову можна перевести у десяткову форму, якщо потрібно.

*/
