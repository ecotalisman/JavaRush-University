package ua.javarush.task.pro.task13.task1326;

import java.util.Queue;

/*
В чергу!
Напишемо просту реалізацію черги.

Клас MyQueue успадковує AbstractQueue<String>, тобі потрібно реалізувати 5 методів. Значення зберігатимуться у списку
values.

Елементи, які повинні додаватися у хвіст черги, додаватимуться в кінець values. Елемент з індексом 0 у values
вважатиметься головою черги.


Requirements:
1. Метод iterator повинен повернути listIterator() списку values.
2. Метод size повинен повернути розмір списку values.
3. Метод offer повинен додати новий елемент до кінця списку values і повернути true.
4. Метод poll повинен повернути елемент з індексом 0 у списку values і видалити його зі списку.
Якщо список порожній, то повернути null.
5. Метод peek повинен просто повернути елемент з індексом 0 у списку values. Якщо список порожній, то повернути null.
*/

public class Solution {

    public static void main(String[] args) {
        Queue<String> queue = new MyQueue();

        for (int i = 0; i < 10; i++) {
            queue.offer("елемент " + i);
        }
        System.out.println("довжина черги: " + queue.size());

        System.out.println("*** iterator ***");
        for (Object o : queue) {
            System.out.println(o);
        }

        System.out.println("*** peek ***");
        for (int i = 0; i < 12; i++) {
            System.out.println(queue.peek());
        }

        System.out.println("*** poll ***");
        for (int i = 0; i < 12; i++) {
            System.out.println(queue.poll());
        }

        System.out.println("довжина черги: " + queue.size());
    }
}

/*
Стосовно одного з основних принципів ООП - поліморфізму. В Java і багатьох інших об'єктно-орієнтованих мовах
програмування ми можемо використовувати батьківський тип (або інтерфейс) для посилання на об'єкт підкласу.

Queue<String> - це інтерфейс у Java, який визначає контракт для роботи з чергою (queue) об'єктів. MyQueue - це
конкретна реалізація цього інтерфейсу. Коли ми пишемо:

        Queue<String> queue = new MyQueue();

ми створюємо новий об'єкт типу MyQueue, але посилання на цей об'єкт має тип Queue<String>. Це означає, що ми можемо
використовувати з цим об'єктом тільки методи, які визначені в інтерфейсі Queue<String>.

Це корисно, оскільки дозволяє вам писати код, який працює з будь-якими об'єктами, що реалізують Queue<String>, не залежачи
від того, яка конкретна реалізація використовується. Це використовується для поліморфізму, одного з ключових принципів ООП.

********************************************************************************************************************************

LinkedList (class) implements від Deque (interface)
а Deque (interface) extends Queu (interface)
Queu (interface) extends Collection (interface)
Collection (interface) extends Iterable (interface)

implements в Java використовується для вказівки на те, що клас реалізує певний інтерфейс. Інтерфейс у Java - це
контракт, який гарантує, що клас, який його реалізує, матиме певні методи. Коли клас реалізує інтерфейс, він повинен
надати реалізацію для всіх методів, визначених в інтерфейсі.

У вашому питанні, LinkedList - це клас, який реалізує інтерфейс Deque. Це означає, що LinkedList має реалізувати всі
методи, визначені в Deque.

extends в Java використовується, коли один інтерфейс наслідує інший, або коли один клас наслідує інший. Інтерфейс,
який розширює інший інтерфейс, успадковує всі його методи. Тому, коли Deque розширює Queue, він успадковує всі методи
Queue. Так само, коли Queue розширює Collection, він успадковує всі методи Collection, і коли Collection розширює
Iterable, він успадковує всі методи Iterable.

Отже, коли LinkedList реалізує Deque, він не тільки повинен реалізувати всі методи Deque, але й всі методи Queue,
Collection, і Iterable, які Deque успадковує.

*/