package ua.javarush.task.pro.task13.task1313;

public class StringLinkedList {
    private Node first = new Node();
    private Node last = new Node();

    public void printAll() {
        Node currentElement = first.next;
        while ((currentElement) != null) {
            System.out.println(currentElement.value);
            currentElement = currentElement.next;
        }
    }

    public void add(String value) {
        //напишіть тут ваш код
        Node newNode = new Node();
        newNode.value = value;

        if (first.next == null) {
            // список порожній, тому новий вузол буде і першим, і останнім
            first.next = newNode;
            newNode.prev = first;
            last.prev = newNode;
            newNode.next = last;
        } else {
            // список не порожній, тому новий вузол буде доданий в кінець
            Node oldLastNode  = last.prev;
            oldLastNode.next = newNode;
            newNode.prev = oldLastNode;
            last.prev = newNode;
            newNode.next = last;
        }
    }

    public static class Node {
        private Node prev;
        private String value;
        private Node next;
    }
}


/*

У коді, first та last - це об'єкти внутрішнього класу Node, які використовуються в якості початкового та кінцевого
елементів зв'язного списку. Вони служать "орієнтирами" для вказівки на початок та кінець списку відповідно.

Коли ми пишемо first.next, ми отримуємо посилання на наступний елемент після first, а не присвоюєте first значення next.

Якщо ми говоримо про об'єкт типу Node, то поле next в цьому об'єкті - це посилання на наступний об'єкт типу Node у
зв'язному списку. Тобто, якщо у нас є об'єкт Node A, то A.next - це посилання на наступний об'єкт типу Node у списку після A.

Таким чином, коли ми пишемо first.next, ми отримуємо посилання на об'єкт типу Node, який йде після first у зв'язному
списку. Тобто, first.next - це другий елемент списку.

Додатково, поля типу Node у внутрішньому класі Node (prev та next) вказують на попередній та наступний об'єкти у
списку відповідно. Це дозволяє нам переміщатися вперед і назад по списку, змінюючи поточний елемент.

У нашому випадку first та last - це об'єкти класу Node, які використовуються в якості фіктивних вузлів (вони також
називаються "дамі" або "черепашки") в двобічно зв'язаному списку. Ці вузли використовуються для спрощення логіки роботи
зі списком. Вони не містять значень (value), а їхні next та prev посилання використовуються для вказівки на перший та
останній реальні вузли списку відповідно.

Коли ми пишемо first.next, ми не присвоюємо об'єкту first значення next. Ви отримуєте посилання на вузол, на який
вказує first.next.

Клас Node має поля prev та next, які є посиланнями на інші об'єкти класу Node. Це дозволяє створити зв'язки між вузлами
у двобічно зв'язаному списку. Кожен вузол знає про свій попередній та наступний вузли, що дозволяє нам переміщатися
вперед та назад по списку.

1) private Node prev, next; - це оголошення змінних prev та next, які є типом Node. Ці змінні представляють собою
посилання на інші об'єкти Node. Вони використовуються для збереження об'єктів Node, які ідуть перед та після поточного
об'єкта Node в двобічно зв'язаному списку.

2) Node currentElement = first.next; - цей рядок означає, що ми створюємо нову змінну currentElement типу Node і
присвоюємо їй посилання на об'єкт, на який вказує first.next.
first.next - це не значення, а посилання на об'єкт типу Node. Це означає, що currentElement тепер вказує на той же
об'єкт, на який вказує first.next.

У коді first та last використовуються як "заглушки" (англ. "dummy nodes") для полегшення роботи зі списком.
Вони завжди вказують на початок та кінець списку відповідно, але самі не містять корисних даних (value).

*/