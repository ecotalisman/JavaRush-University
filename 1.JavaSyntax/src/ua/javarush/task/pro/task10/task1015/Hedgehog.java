package ua.javarush.task.pro.task10.task1015;

/* 
Їжачок і яблуко
Наше завдання — нагодувати їжачка. У методі main слід створити один об'єкт Apple і один об'єкт Hedgehog, у якого
викликати метод eat і передати потрібний аргумент — яблуко.


Requirements:
1. Клас Hedgehog має містити вкладений клас public static class Apple.
2. Клас Hedgehog має містити нестатичний публічний метод eat(Apple) з типом повернення void.
3. У методі main має бути створено один об'єкт класу Apple.
4. У методі main має бути створено один об'єкт класу Hedgehog.
5. У методі main для об'єкта класу Hedgehog потрібно викликати метод eat і передати створений об'єкт класу Apple.
*/

public class Hedgehog {

    public void eat(Apple apple) {
        System.out.println("Яблуко з'їли!");
    }

    public static void main(String[] args) {
        //напишіть тут ваш код

//        Apple apple = new Apple();
//        Hedgehog hedgehog = new Hedgehog();
//        hedgehog.eat(apple);

        new Hedgehog().eat(new Apple());

    }

    public static class Apple {
    }
}

/*
обидва коди роблять те саме, але вони мають деякі відмінності:

1) В першому варіанті об'єкти Apple та Hedgehog створюються безпосередньо під час виклику методу eat. Це означає, що
об'єкти не мають посилань на них, і вони не можуть бути використані знову в майбутньому в методі main. Це корисно,
якщо вам не потрібно зберігати посилання на об'єкти для подальшого використання.

new Hedgehog().eat(new Apple());

2) У другому варіанті ви створюєте змінні apple та hedgehog для зберігання посилань на об'єкти. Це означає, що ви
можете використовувати ці посилання в майбутньому в методі main для виконання інших операцій з цими об'єктами.

Apple apple = new Apple();
Hedgehog hedgehog = new Hedgehog();
hedgehog.eat(apple);

Загалом, вибір між двома варіантами залежить від того, чи потрібно вам зберігати посилання на об'єкти для подальшого
використання в коді.
*/