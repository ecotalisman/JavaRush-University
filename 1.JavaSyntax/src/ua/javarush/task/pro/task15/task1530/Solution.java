package ua.javarush.task.pro.task15.task1530;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;

/* 
Байти у символи
У класі Solution створи публічний статичний метод bytesToChars(ByteArrayInputStream stream, int n), що повертає char[].
Метод повинен зчитати n перших байт із stream і перетворити їх на масив символів. Повернений масив повинен мати довжину
n або менше, якщо в потоці менше ніж n байт.
Вважаємо, що кожен байт відповідає одному символу.

Requirements:
1. У класі Solution має бути створений метод public static char[] bytesToChars(ByteArrayInputStream stream, int n).
2. Метод bytesToChars повинен перетворити перші n байт із stream на символи та повернути їх у вигляді масиву.
*/

public class Solution {

    public static void main(String[] args) {
        ByteArrayInputStream stream = new ByteArrayInputStream("O sole, o sole mio!\nSta 'nfronte a te!\n Sta 'nfronte a te!".getBytes(StandardCharsets.UTF_8));
        System.out.println(new String(bytesToChars(stream, 38)));
    }

    //напишіть тут ваш код
    public static char[] bytesToChars(ByteArrayInputStream stream, int n) {

        char[] chars = new char[n];
        int count = 0;

        while (count < n && stream.available() > 0) {
            chars[count] = (char) stream.read();
            count++;
        }

        if (count < n) {
            char[] smallerChars = new char[count];
            System.arraycopy(chars, 0, smallerChars, 0, count);
            chars = smallerChars;
        }

        return chars;
    }
}

/*

В Java System.arraycopy() - це вбудований метод, який використовується для копіювання даних з одного масиву в інший.

У цьому випадку, System.arraycopy(chars, 0, smallerChars, 0, count); копіює вміст масиву chars в масив smallerChars.
Аргументи методу System.arraycopy() мають наступне значення:

* Перший аргумент (chars) - це джерельний масив.
* Другий аргумент (0) - це початкова позиція в джерельному масиві з якої почнеться копіювання.
* Третій аргумент (smallerChars) - це цільовий масив, в який будуть копіюватися дані.
* Четвертий аргумент (0) - це початкова позиція в цільовому масиві, куди будуть копіюватися дані.
* П'ятий аргумент (count) - це кількість елементів, які потрібно скопіювати.

chars = smallerChars; - ця строка означає, що посилання chars тепер вказує на масив smallerChars. Таким чином,
ми "обрізали" початковий масив chars до розміру smallerChars (або до кількості байтів, які були дійсно прочитані з потоку).

***************************************************************************************************************************************

Масив smallerChars буде використовуватися у випадку, якщо кількість байтів доступних для читання з stream менше,
ніж запитана кількість n.

Отже, якщо ви запитуєте n байтів з вхідного потоку, але він має менше байтів, ніж n, то у цьому випадку використовується
масив smallerChars.

Припустимо, ви маєте вхідний потік даних з 50 байтами, але ви запросили 100 байт. У цьому випадку, вхідний потік може
забезпечити лише 50 байтів, тому кінцевий масив символів повинен бути розміром 50, а не 100. Ось тут і використовується
масив smallerChars.

if (count < n) перевіряє, чи було прочитано менше байт, ніж n. Якщо це так, то створюється новий масив smallerChars
розміром count (кількість прочитаних байт) і дані з оригінального масиву chars копіюються в smallerChars з використанням
System.arraycopy(). За допомогою цього коду оригінальний масив chars "обрізається" до розміру реально прочитаних байт.

Потім chars присвоюється посилання на smallerChars, таким чином chars тепер має розмір count. Таким чином ми повертаємо
масив символів розміром n або менше, якщо в потоці було менше ніж n байт.

***************************************************************************************************************************************

Строка "O sole, o sole mio!\nSta 'nfronte a te!\n Sta 'nfronte a te!" має 58 символів (включаючи пробіли та переходи
на новий рядок). Згідно з кодуванням UTF-8, кожен символ кодується в один байт, тому ми маємо 58 байтів.

Якщо ви встановите n більше 58 (наприклад, n = 59 або n = 100), код створить масив chars довжиною n і спробує
зчитати n байт. Але коли буде зчитано 58 байт, потік даних закінчиться, і зчитування зупиниться. У цьому випадку,
count буде рівним 58, що менше, ніж n. Тоді smallerChars буде створено для зменшення розміру масиву до дійсної кількості
прочитаних байт (58 в даному випадку).

*/