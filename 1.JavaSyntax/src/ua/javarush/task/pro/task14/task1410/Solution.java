package ua.javarush.task.pro.task14.task1410;

import java.io.FileNotFoundException;
import java.nio.file.FileSystemException;

/* 
Обгортання винятків
У методі copyFile перехопи винятки, що їх кидають методи readFile і writeFile.
Перехоплені винятки обгорни винятком RuntimeException і прокинь далі.

Requirements:
1. У методі copyFile мають перехоплюватися винятки FileNotFoundException і FileSystemException.
2. Усі перехоплені винятки потрібно обгортати винятком RuntimeException і прокидати далі.
3. Метод copyFile не повинен містити винятків у секції throws.
*/

public class Solution {

    public static void main(String[] args) {
        copyFile("book.txt", "book_final_copy.txt");
        copyFile("book_final_copy.txt", "book_last_copy.txt");
    }

    static void copyFile(String sourceFile, String destinationFile) {

        // It was a condition:
//        FileUtils.readFile(sourceFile);
//        FileUtils.writeFile(destinationFile);

        //напишіть тут ваш код
        try {
            FileUtils.readFile(sourceFile);
            FileUtils.writeFile(destinationFile);

        } catch (FileSystemException | FileNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
}


/*

Метод обгортання винятків є корисним при обробці винятків, які є обов'язковими (checked) в Java. Ці винятки мають бути
вказані в сигнатурі методу за допомогою ключового слова throws, або ж мають бути оброблені за допомогою try/catch.
Це означає, що при виклику методу, який може викидати перевірені винятки, ці винятки також мають бути або оброблені,
або вказані в сигнатурі викликаючого методу. Це може призвести до великого накладу роботи, особливо якщо виняток
поширюється через велику кількість методів.

Щоб уникнути цієї проблеми, можна "згорнути" перевірені винятки в неперевірені (unchecked) винятки. Це означає,
що ви створюєте новий випадок RuntimeException (або будь-якого іншого підкласу RuntimeException), і передаєте перевірений
виняток як причину (cause) нового винятка. Тоді викидаєте новий виняток. Це означає, що викликаючий код не змушений
обробляти виняток, але все ще може виконати це, якщо хоче, за допомогою методу getCause() на винятку RuntimeException.

Таким чином, обгортання винятків дозволяє вам обробляти винятки в більш гнучкий і управліний спосіб, зменшуючи потребу
в поширенні перевірених винятків через багато різних методів.

*********************************************************************************************************************************

Винятки в Java поділяються на дві основні категорії: перевірені (checked) та неперевірені (unchecked).

1) Checked exceptions: Це винятки, які Java компілятор вимагає обробити або вказати в сигнатурі методу за допомогою
оператора throws. Вони наслідуються від класу java.lang.Exception і зазвичай відображають помилки, що можуть виникнути
при нормальній роботі програми, наприклад, IOException при читанні файлу, який не існує.

2) Unchecked exceptions: Це винятки, які Java компілятор не вимагає обробляти або вказувати в сигнатурі методу. Вони
наслідуються від класу java.lang.RuntimeException і зазвичай відображають програмні помилки, як, наприклад,
NullPointerException, коли ви намагаєтеся використати об'єкт, який ще не було ініціалізовано.

Коли IDE пропонує вам обробити виняток, це, зазвичай, означає, що ви використовуєте код, який може викинути перевірений
виняток, і компілятор вимагає, щоб ви обробили цей виняток за допомогою блоку try/catch, або вказали його в сигнатурі
методу за допомогою оператора throws.

У контексті обгортання винятків, який був описаний раніше, ви "згортаєте" перевірені винятки (які вимагає обробити
компілятор) в неперевірені, щоб зменшити потребу в явній обробці цих винятків в багатьох місцях вашого коду.

*/