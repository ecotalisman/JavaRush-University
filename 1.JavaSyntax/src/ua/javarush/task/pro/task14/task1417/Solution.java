package ua.javarush.task.pro.task14.task1417;

/* 
Валідатор дати
Давай реалізуємо валідатор дати. Формат дати — dd.mm.yyyy, де dd — номер дня в місяці, mm — номер місяця у році,
yyyy — рік.

Дата перевіряється у методі checkDateFormat(String), якщо дата не відповідає формату, то метод повинен викинути виняток
InvalidDateFormatException.
У разі правильного формату перевіряємо рік, місяць і день у відповідних методах checkYearValue, checkMonthValue
 і checkDayValue:

рік має бути в діапазоні від 1900 до 2100 включно, інакше кидаємо виняток InvalidYearValueException;
місяць має бути в діапазоні від 1 до 12 включно, інакше кидаємо виняток InvalidMonthValueException;
день повинен бути в діапазоні від 1 до максимального значення дня цього місяця (див. мапу months) включно, інакше
кидаємо виняток InvalidDayValueException.
Ці винятки потрібно створити в окремих класах (файлах), успадкувавши їх від RuntimeException.

Приклади валідної дати: 31.05.1900, 28.02.2100, 01.01.2000, 30.11.2021, 15.09.1999.
Приклади невалідної дати: 32.05.1900, 28.02.2101, 30.01.1874, 30.02.2021, 150.09.1999, 05.111.2046, 15.91.1967, 150.09.19999.


Requirements:
1. Сигнатуру і тип значення, що повертається, методу checkDateFormat(String) не змінюй.
2. Сигнатуру і тип значення, що повертається, методу checkYearValue(String) не змінюй.
3. Сигнатуру і тип значення, що повертається, методу checkMonthValue(String) не змінюй.
4. Сигнатуру і тип значення, що повертається, методу checkDayValue(String) не змінюй.
5. Публічний клас InvalidDateFormatException має бути створений в окремому файлі та успадковуватись від класу RuntimeException.
6. Публічний клас InvalidYearValueException має бути створений в окремому файлі та успадковуватися від класу RuntimeException.
7. Публічний клас InvalidMonthValueException має бути створений в окремому файлі та успадковуватися від класу RuntimeException.
8. Публічний клас InvalidDayValueException має бути створений в окремому файлі та успадковуватися від класу RuntimeException.
9. Метод checkDateFormat має бути реалізований згідно з умовою.
10. Метод checkYearValue має бути реалізований згідно з умовою.
11. Метод checkMonthValue має бути реалізований згідно з умовою.
12. Метод checkDayValue має бути реалізований згідно з умовою.
*/

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Введи дату у форматі dd.mm.yyyy : ");
        String date = scanner.nextLine();
        validateDate(date);
        System.out.println("\nДата коректна.");
    }

    public static void validateDate(String date) {
        checkDateFormat(date);
        checkYearValue(date);
        checkMonthValue(date);
        checkDayValue(date);
    }

    public static void checkDateFormat(String date) {
        //напишіть тут ваш код
        if (!date.matches("\\d{2}\\.\\d{2}\\.\\d{4}")) {
            throw new InvalidDateFormatException();
        }
    }

    public static void checkYearValue(String date) {
        //напишіть тут ваш код
        int year = Integer.parseInt(date.split("\\.")[2]);
        if (year < 1900 || year > 2100) {
            throw new InvalidYearValueException();
        }
    }

    public static void checkMonthValue(String date) {
        //напишіть тут ваш код
        int month = Integer.parseInt(date.split("\\.")[1]);
        if (month < 1 || month > 12) {
            throw new InvalidMonthValueException();
        }
    }

    public static void checkDayValue(String date) {
        HashMap<Integer, Integer> months = new HashMap<>(){{
            put(1, 31);
            put(2, 29);
            put(3, 31);
            put(4, 30);
            put(5, 31);
            put(6, 30);
            put(7, 31);
            put(8, 31);
            put(9, 30);
            put(10, 31);
            put(11, 30);
            put(12, 31);
        }};
        //напишіть тут ваш код
        int day = Integer.parseInt(date.split("\\.")[0]);
        int month = Integer.parseInt(date.split("\\.")[1]);

        for (Map.Entry<Integer, Integer> entry : months.entrySet()) {
            if (entry.getKey().equals(month) && (day < 1 || day > entry.getValue())) {
                throw new InvalidDayValueException();
            }
        }

        // Second Version (for Leap Year):
//        int day = Integer.parseInt(date.split("\\.")[0]);
//        int month = Integer.parseInt(date.split("\\.")[1]);
//        int year = Integer.parseInt(date.split("\\.")[2]);
//
//        int maxDay = months.get(month);
//
//        // For leap year case:
//        if (month == 2 && !(year % 400 == 0 || (year % 4 == 0 && year % 100 != 0))) {
//            maxDay = 28;
//        }
//
//        // A year is considered a leap year if it is divisible by 4.
//        // However, there is an exception for years that are divisible by 100 (such years are leap years only if they
//        // are also divisible by 400).
//
//        // Ukrainian:
//        // Рік вважається високосним, якщо він ділиться на 4.
//        // Винятком є роки, які кратні 100 (такі роки є високосними тільки тоді, якщо вони ще діляться на 400)
//
//        if (day < 1 || day > maxDay) {
//            throw new InvalidDayValueException();
//        }

    }
}

/*

1. checkDateFormat(String date) - цей метод перевіряє, чи відповідає введена строка формату дати. Для цього використовується
метод matches() для строки, що приймає регулярний вираз. Регулярний вираз \\d{2}\\.\\d{2}\\.\\d{4} відповідає строкам,
що мають дві цифри, потім крапку, потім ще дві цифри, потім крапку, і в кінці - чотири цифри. Це відповідає формату
дати "dd.mm.yyyy". Якщо строка не відповідає цьому формату, метод викликає виняток InvalidDateFormatException.

2. checkYearValue(String date) - цей метод перевіряє, чи відповідає рік в даті допустимому діапазону (від 1900 до
2100 року включно). Спочатку він використовує метод split("\\."), щоб розділити введену строку на окремі частини за
крапкою. Результатом є масив рядків, де перший елемент (індекс 0) - це день, другий елемент (індекс 1) - це місяць,
і третій елемент (індекс 2) - це рік. Ми беремо рік за допомогою date.split("\\.")[2] і перетворюємо його на ціле число
за допомогою Integer.parseInt(). Потім ми перевіряємо, чи рік входить в допустимий діапазон. Якщо це не так, ми викликаємо
виняток InvalidYearValueException.

\\d{2}\\.\\d{2}\\.\\d{4}
Цей вираз - це регулярний вираз, який використовується для знаходження паттерну в тексті. Розберемо його:

\\d - це спеціальний символ, який вказує на будь-яку одну цифру (0-9). Одинарний \d в Java представляє одну цифру,
але нам потрібно використовувати подвійний слеш \\d, тому що \ сам по собі є спеціальним символом в рядках Java, тому
його потрібно екранувати.

{2} - це квантифікатор, який вказує, скільки разів попередній символ або група символів повинна повторюватися. У цьому
випадку \\d{2} вказує на дві цифри.

\\. - це крапка. Так як крапка є спеціальним символом в регулярних виразах (вона відповідає будь-якому символу), нам
потрібно її екранувати за допомогою подвійного слеша \\, щоб вказати на літеральний символ крапки.

Таким чином, вираз \\d{2}\\.\\d{2}\\.\\d{4} відповідає будь-якому рядку, що має дві цифри, потім крапку, потім ще дві
цифри, потім крапку, і в кінці - чотири цифри. Це відповідає формату дати "dd.mm.yyyy".


******************************************************************************************************************************************************************

Пояснення до методу `split` класу `String`:

******************************************************************************************************************************************************************

Цей метод ділить рядок навколо збігів заданого регулярного виразу.

Цей метод працює так, як якби було викликано двоаргументний метод split з заданим виразом та аргументом ліміту, що
дорівнює нулю. Таким чином, порожні рядки в кінці не включаються до результуючого масиву.

Наприклад, рядок "boo:and:foo" дає наступні результати з цими виразами:

Регулярний вираз ":" дає результат {"boo", "and", "foo"}
Регулярний вираз "o" дає результат {"b", "", ":and:f"}
Параметр:

regex - регулярний вираз, що служить роздільником

Повертає:
масив рядків, обчислених шляхом розділення цього рядка навколо збігів заданого регулярного виразу

Виняток:
PatternSyntaxException - якщо синтаксис регулярного виразу є недійсним


Пояснення:
Метод split використовується для розділення рядка на підрядки, розділені визначеним регулярним виразом, і повертає ці
підрядки у вигляді масиву.

Так, наприклад, якщо у вас є рядок "Hello, World!" і ви хочете поділити його на окремі слова, ви можете використати
рядок з комою та пробілом як регулярний вираз: split(", "). Це поверне масив з двох елементів: {"Hello", "World!"}.

Варто зауважити, що метод split не включає порожні рядки на кінці результуючого масиву. Тобто, якщо у вас є рядок
"a,b,,", метод split(",") поверне масив {"a", "b"}, а не {"a", "b", "", ""}.

******************************************************************************************************************************************************************

public String[] split(String regex) {
        return split(regex, 0);
    }

Метод public String[] split(String regex) це просто обгортка для двоаргументного методу split(String regex, int limit),
що забезпечує зручність, якщо ви не хочете задавати обмеження на кількість виконаних розділень.

У цьому методі regex - це регулярний вираз, за яким ви хочете розділити рядок, а limit - це максимальна кількість виконаних
розділень. Якщо limit дорівнює 0, то кількість виконаних розділень не обмежена.

Таким чином, виклик split(regex) еквівалентний виклику split(regex, 0), який розділяє рядок на підрядки за регулярним
виразом без обмеження кількості виконаних розділень.


Параметр limit у методі split(String regex, int limit) визначає максимальну кількість підрядків, що можуть бути в
результаті розділення.

Якщо limit дорівнює 2, то це означає, що буде здійснено лише одне розділення і отримано не більше двох підрядків.

Наприклад, якщо маємо рядок "01.02.2003" і розділяємо його за допомогою методу split("\\.", 2), то ми отримаємо масив
із двох елементів: "01" і "02.2003".

В цьому прикладі перше розділення відбувається на першій крапці, але подальше розділення не відбувається, тому що ми
вже досягли максимальної кількості підрядків (2), вказаної в limit.

Таким чином, якщо ви встановите limit = 2, то масив String[] матиме розмір 2 (String[0] і String[1]), якщо вхідний
рядок містить хоча б одну відповідність до регулярного виразу.

******************************************************************************************************************************************************************

У Java ми можемо ітерувати HashMap кількома різними способами. Ось деякі з них:

1. Ітерація за допомогою for-each циклу і Map.Entry:

HashMap<Integer, Integer> months = new HashMap<>(){{
    put(1, 31);
    put(2, 29);
    put(3, 31);
    put(4, 30);
    put(5, 31);
    put(6, 30);
    put(7, 31);
    put(8, 31);
    put(9, 30);
    put(10, 31);
    put(11, 30);
    put(12, 31);
}};

for (Map.Entry<Integer, Integer> entry : months.entrySet()) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}


2. Ітерація за допомогою Iterator:

HashMap<Integer, Integer> months = new HashMap<>(){{
    put(1, 31);
    put(2, 29);
    put(3, 31);
    put(4, 30);
    put(5, 31);
    put(6, 30);
    put(7, 31);
    put(8, 31);
    put(9, 30);
    put(10, 31);
    put(11, 30);
    put(12, 31);
}};

Iterator<Map.Entry<Integer, Integer>> iterator = months.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, Integer> entry = iterator.next();
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}


3. Ітерація тільки по ключах або значенням:

HashMap<Integer, Integer> months = new HashMap<>(){{
    put(1, 31);
    put(2, 29);
    put(3, 31);
    put(4, 30);
    put(5, 31);
    put(6, 30);
    put(7, 31);
    put(8, 31);
    put(9, 30);
    put(10, 31);
    put(11, 30);
    put(12, 31);
}};

for (Integer key : months.keySet()) {
    System.out.println("Key: " + key);
}

for (Integer value : months.values()) {
    System.out.println("Value: " + value);
}


Кожен з цих методів має свої переваги в залежності від вашого конкретного використання.

*/
