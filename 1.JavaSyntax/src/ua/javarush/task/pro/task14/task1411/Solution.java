package ua.javarush.task.pro.task14.task1411;

import java.io.FileNotFoundException;
import java.nio.file.FileSystemException;

/* 
Розпакування винятків
У методі main перехопи RuntimeException. Визнач, який виняток в ньому збережено.
Якщо це FileNotFoundException, виведи в консоль повідомлення "Не вдалося прочитати файл.", а якщо
FileSystemException — "Не вдалося записати у файл.".

Requirements:
1. У методі main має перехоплюватися RuntimeException.
2. Потрібно вивести "Не вдалося прочитати файл.", якщо в RuntimeException упаковано FileNotFoundException.
3. Потрібно вивести "Не вдалося записати у файл.", якщо в RuntimeException упаковано FileSystemException.
4. Клас FileManager не змінюй.
*/

public class Solution {

    public static final String FAILED_TO_READ = "Не вдалося прочитати файл.";
    public static final String FAILED_TO_WRITE = "Не вдалося записати у файл.";

    public static FileManager fileManager = new FileManager();

    public static void main(String[] args) {

        // It was a condition:
//        fileManager.copyFile("book.txt", "book_final_copy.txt");
//        fileManager.copyFile("book_final_copy.txt", "book_last_copy.txt");

        //напишіть тут ваш код
       try {
           fileManager.copyFile("book.txt", "book_final_copy.txt");
           fileManager.copyFile("book_final_copy.txt", "book_last_copy.txt");
       } catch (RuntimeException e) {
           Throwable cause = e.getCause();
           if (cause instanceof FileNotFoundException) {
               System.out.println(FAILED_TO_READ);
           } else if (cause instanceof FileSystemException) {
               System.out.println(FAILED_TO_WRITE);
           }
       }

    }
}

/*

Код, це приклад обробки винятків, які були "загорнуті" в RuntimeException в методі copyFile класу
FileManager. Це дозволяє нам використовувати цей метод без необхідності обробки перевірених винятків FileNotFoundException
та FileSystemException, які можуть виникнути під час виконання readFile і writeFile методів відповідно.

У методі main ми потім перехоплюємо RuntimeException і визначаємо, який виняток був збережений у ньому за допомогою
методу getCause(). Це дозволяє нам відреагувати на конкретний виняток, що виник під час копіювання файлу, залежно від
того, чи це FileNotFoundException або FileSystemException.

Цей підхід є досить розповсюдженим для обробки винятків, коли нам потрібно виконати деяку дію, яка може викликати
декілька різних типів винятків, і ми хочемо обробити кожен з них окремо.

*********************************************************************************************************************************

Метод обгортання винятків є корисним при обробці винятків, які є обов'язковими (checked) в Java. Ці винятки мають бути
вказані в сигнатурі методу за допомогою ключового слова throws, або ж мають бути оброблені за допомогою try/catch.
Це означає, що при виклику методу, який може викидати перевірені винятки, ці винятки також мають бути або оброблені,
або вказані в сигнатурі викликаючого методу. Це може призвести до великого накладу роботи, особливо якщо виняток
поширюється через велику кількість методів.

Щоб уникнути цієї проблеми, можна "згорнути" перевірені винятки в неперевірені (unchecked) винятки. Це означає,
що ви створюєте новий випадок RuntimeException (або будь-якого іншого підкласу RuntimeException), і передаєте перевірений
виняток як причину (cause) нового винятка. Тоді викидаєте новий виняток. Це означає, що викликаючий код не змушений
обробляти виняток, але все ще може виконати це, якщо хоче, за допомогою методу getCause() на винятку RuntimeException.

Таким чином, обгортання винятків дозволяє вам обробляти винятки в більш гнучкий і управліний спосіб, зменшуючи потребу
в поширенні перевірених винятків через багато різних методів.

*********************************************************************************************************************************

Винятки в Java поділяються на дві основні категорії: перевірені (checked) та неперевірені (unchecked).

1) Checked exceptions: Це винятки, які Java компілятор вимагає обробити або вказати в сигнатурі методу за допомогою
оператора throws. Вони наслідуються від класу java.lang.Exception і зазвичай відображають помилки, що можуть виникнути
при нормальній роботі програми, наприклад, IOException при читанні файлу, який не існує.

2) Unchecked exceptions: Це винятки, які Java компілятор не вимагає обробляти або вказувати в сигнатурі методу. Вони
наслідуються від класу java.lang.RuntimeException і зазвичай відображають програмні помилки, як, наприклад,
NullPointerException, коли ви намагаєтеся використати об'єкт, який ще не було ініціалізовано.

Коли IDE пропонує вам обробити виняток, це, зазвичай, означає, що ви використовуєте код, який може викинути перевірений
виняток, і компілятор вимагає, щоб ви обробили цей виняток за допомогою блоку try/catch, або вказали його в сигнатурі
методу за допомогою оператора throws.

У контексті обгортання винятків, який був описаний раніше, ви "згортаєте" перевірені винятки (які вимагає обробити
компілятор) в неперевірені, щоб зменшити потребу в явній обробці цих винятків в багатьох місцях вашого коду.

*/