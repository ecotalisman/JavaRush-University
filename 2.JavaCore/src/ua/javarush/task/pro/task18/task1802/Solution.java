package ua.javarush.task.pro.task18.task1802;

import java.util.ArrayList;
import java.util.Collections;

public class Solution {
    public static ArrayList<Student> students = new ArrayList<>();

    public static void main(String[] args) {
        Collections.addAll(students,
                new Student("Іваненко", 22),
                new Student("Петренко", 18),
                new Student("Сидоренко", 19)
        );

        Collections.sort(students, new AgeComparator());

        for (Student student : students) {
            System.out.println(student);
        }
    }
}

/*

Метод compare() в компараторі використовується для порівняння двох об'єктів. Ці об'єкти передаються в метод в порядку,
в якому вони розташовані в списку. Ви вірно зрозуміли, як викликається цей метод.

Однак, тут є важливий момент щодо порядку об'єктів у методі compare(). Якщо ви використовуєте o2.getAge() - o1.getAge(),
то порядок сортування буде від більшого до меншого (тобто від старшого студента до молодшого), адже ви віднімаєте вік
першого студента від віку другого. Якщо б ви зробили навпаки, o1.getAge() - o2.getAge(), то порядок сортування був би
від меншого до більшого (тобто від молодшого студента до старшого).

У вашому випадку, коли ви викликаєте Collections.sort(students, new AgeComparator()), метод compare() в AgeComparator
викликається для кожної пари сусідніх студентів у списку. Спочатку порівнюються Іваненко і Петренко,
потім Петренко і Сидоренко.

Тому, при виклику o2.getAge() - o1.getAge(), ви отримуєте:

1. Петренко (18) - Іваненко (22) = -4
2. Сидоренко (19) - Петренко (18) = 1

Значення, яке повертається в результаті виконання compare(), визначає, який з двох об'єктів іде першим в
сортованому списку. Якщо це значення додатне, то перший об'єкт (o1) іде після другого (o2).
Якщо від'ємне - то перший об'єкт (o1) йде перед другим (o2). Якщо 0 - порядок об'єктів не змінюється.

Сортування використовує алгоритм, який вибирає пари об'єктів для порівняння не послідовно, а відповідно до своєї
внутрішньої логіки. У випадку з Java, метод Collections.sort() використовує алгоритм TimSort (або інший залежно
від версії Java), який оптимізований для різних сценаріїв.

Отже, порядок, в якому пари об'єктів передаються в метод compare(), може здаватися дещо хаотичним. Наприклад,
він може спершу порівняти перший і останній об'єкти, потім останній і середній, і т.д., в залежності від того,
як алгоритм сортування вирішує поділити і завоювати дані.

Саме тому ви бачите, що o1 та o2 в методі compare() не завжди є сусідніми студентами в списку, і їх порядок може
відрізнятися від порядку, в якому ви їх додали до списку.

*/