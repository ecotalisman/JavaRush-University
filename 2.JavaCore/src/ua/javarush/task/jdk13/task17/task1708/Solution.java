package ua.javarush.task.jdk13.task17.task1708;

import java.util.ArrayList;
import java.util.List;

/* 
Нотатки для всіх
Клас Note буде використовуватися потоками.
Тому зроби так, щоб список notes знаходився у загальній пам'яті, тобто не буде кешуватися потоками в свою локальну
область пам'яті.

Requirements:
1. Клас Note повинен містити метод addNote(int index, String note).
2. Клас Note повинен містити метод removeNote(int index).
3. Клас Note повинен містити публічне поле List<String> notes.
4. Поле List<String> notes не має знаходитися в локальному кеші.
*/

public class Solution {

    public static void main(String[] args) {

    }

    public static class Note {

        public volatile List<String> notes = new ArrayList<String>();

        public void addNote(int index, String note) {
            System.out.println("Зараз буде додано нотатку [" + note + "] На позицію " + index);
            notes.add(index, note);
            System.out.println("Вже додано нотатку [" + note + "]");
        }

        public void removeNote(int index) {
            System.out.println("Зараз буде видалено нотатку з позиції " + index);
            String note = notes.remove(index);
            System.out.println("Вже видалено нотатку [" + note + "] з позиції " + index);
        }
    }
}

/*

код використовує ключове слово volatile для списку notes в класі Note. Це робить змінну видимою для всіх потоків і
запобігає її кешуванню в локальних потоках. Тобто будь-яке оновлення цієї змінної буде видно іншим потокам.

Однак, слід розуміти, що volatile гарантує лише видимість зміни посилання на список, але не гарантує атомарність
операцій з самим списком (додавання, видалення тощо). Тому в багатопотоковому середовищі можуть виникнути проблеми
з консистентністю даних.

У завданні не зазначено, чи потрібно гарантувати атомарність операцій зі списком, тому можна припустити, що
використання volatile є доречним у цьому контексті. Якщо ж потрібно гарантувати безпеку даних при одночасному доступі
декількох потоків, слід використовувати синхронізацію або інші механізми забезпечення конкурентності.

Тому, використання volatile в даному контексті є правильним, якщо завданням було лише забезпечити видимість змінної
для всіх потоків, а не атомарність операцій.

*/