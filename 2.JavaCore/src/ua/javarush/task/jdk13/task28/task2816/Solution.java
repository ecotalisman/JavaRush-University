package ua.javarush.task.jdk13.task28.task2816;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/* 
Рекурсивний алфавіт
Розберися, що робить програма.

У методі call класу Task внеси зміни до рядка виведення на екран, щоб виводилася частина алфавіту від його початку і до letter.

У методі call класу Task внеси зміни до рядка з return, щоб метод повернув частину алфавіту від його початку і до letter.

Наприклад: якщо в Task поле letter дорівнює 'к', то його метод call повинен вивести в консолі й повернути рядок "абвгґдеєжзиіїйк".

Requirements:
1. Не можна змінювати клас Solution.
2. Не можна змінювати конструктор класу Task.
3. Метод call має містити рівно три команди (виклик методів sleep, println, та команду return).
4. Метод call повинен виводити на екран і повертати частину алфавіту від 'а' до letter.
*/

public class Solution {

    public static void main(String[] args) throws Exception {
        String alphabet = "абвгґдеєжзиіїйклмнопрстуфхцчшщьюя";
        ExecutorService stealingPool = Executors.newWorkStealingPool();

        Future<String> future = stealingPool.submit(() -> {
            System.out.println("старт");
            Thread.sleep(100);
            return "";
        });

        for (char c : alphabet.toCharArray()) {
            future = stealingPool.submit(new Task(c, future));
        }

        stealingPool.awaitTermination(1, TimeUnit.SECONDS);
    }
}

/*

У класі Task вам подано два поля: letter (типу char) та future (типу Future<String>).

* letter представляє собою літеру, яка повинна бути виведена.
* future — це об'єкт, який представляє результат виконання якогось іншого завдання (це завдання було передано у
конструкторі Task). Тобто, future зберігає результат виконання попереднього завдання.

В методі call() ви виконуєте наступні дії:

1) Thread.sleep(new Random().nextInt(20)): Спочатку ви робите затримку випадкового часу, що моделює тривалість обчислень
чи іншої діяльності.

2) System.out.println(future.get() + letter): Тут ви викликаєте метод future.get(), який блокує поточний потік до того
моменту, поки результат зазначеного future не буде доступний. Однак, оскільки цей future містить результат виконання
попереднього завдання, виведення future.get() + letter додає літеру letter до результату попереднього завдання, і це
буде виведено на екран.

Коли ви виконуєте цей код в циклі для кожної літери алфавіту, ви створюєте послідовність завдань, де кожне наступне
завдання очікує результат попереднього завдання, а також додає до нього літеру. Таким чином, при виконанні цього циклу,
ви отримуєте вивід алфавіту в послідовності.

****************************************************************************************************************************

future.get() - це метод, який викликається на об'єкті типу Future. Він призначений для отримання результату, який буде
обчислений або повернутий потоком виконання, який асоційований з цим об'єктом Future.

У вас в коді, future є об'єктом типу Future<String>, і коли ви викликаєте future.get(), ви чекаєте, поки обчислення
завершаться (або повернеться результат, якщо воно вже завершилося), і отримуєте значення результата, яке повертається
методом call() у вашому класі Task.

У коді:

System.out.println(future.get() + letter);

Ви отримуєте результат з future, який виводите на екран, а потім додаєте до нього літеру letter. Таким чином, ви
отримуєте послідовність символів, що починається з результата, який вираховується з попередніх завдань, і додаєте до
цього результату поточну літеру letter.

****************************************************************************************************************************

розглянемо приклад з 3 ітераціями для кращого розуміння того, як працює цей код:

Уявімо, що алфавіт складається з літер "а", "б" та "в".

1) Ітерація 1:

letter = 'а'
Потік засинає випадковий період часу (0-19 мс).
Оскільки це перше завдання, future.get() не блокується, і результат виводиться порожній рядок.
System.out.println(future.get() + letter) виводить "а" на екран.
Результат, який повертається, це "а".

2) Ітерація 2:

letter = 'б'
Потік засинає випадковий період часу (0-19 мс).
Тепер future.get() блокується, чекаючи, коли попереднє завдання завершиться.
Попереднє завдання повертає "а".
System.out.println(future.get() + letter) виводить "а" + "б", тобто "аб" на екран.
Результат, який повертається, це "аб".

3) Ітерація 3:

letter = 'в'
Потік засинає випадковий період часу (0-19 мс).
Тепер future.get() знову блокується, чекаючи, коли попереднє завдання завершиться (результат "аб").
System.out.println(future.get() + letter) виводить "аб" + "в", тобто "абв" на екран.
Результат, який повертається, це "абв".

Загалом, цей код використовує future для послідовного обчислення інкрементального результату, що призводить до виводу
та повернення послідовності літер алфавіту.

****************************************************************************************************************************

for (char c : alphabet.toCharArray()) {
            future = stealingPool.submit(new Task(c, future));
        }

В цьому коді, c приймає значення кожної літери алфавіту зі строкового рядка alphabet. Строка alphabet містить усі
літери алфавіту від 'а' до 'я'. Таким чином, на кожній ітерації циклу c отримує наступну літеру з алфавіту.

Початкове значення c не є 0, а є першою літерою алфавіту, тобто 'а'. Літери в Unicode кодуються цілими числами,
і 'а' має код 1072. Однак, зазвичай в програмуванні використовують символи (літери) як такі, а не їх числові значення
в коді Unicode.

Тому, вираз new Task(c, future) передає кожну літеру алфавіту в якості першого аргументу c у конструктор класу Task.
Кожне завдання отримує свою літеру для того, щоб обчислити та вивести відповідну частину алфавіту від 'а' до
поточної літери c.

*/