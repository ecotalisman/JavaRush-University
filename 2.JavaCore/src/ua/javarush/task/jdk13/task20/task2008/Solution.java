package ua.javarush.task.jdk13.task20.task2008;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.dataformat.yaml.YAMLMapper;

/* 
Серіалізація зоопарку
НЕОБХІДНО: підключені бібліотеки jackson-databind та jackson-dataformat-yaml версії 2.13.1.

Зроби так, щоб при серіалізації об'єкта типу Zoo кожному елементу списку animals додався тип (lion для класу Lion,
penguin для класу Penguin).

Requirements:
1. Клас Zoo.Animal потрібно позначити анотацією @JsonTypeInfo.
2. Клас Zoo.Animal потрібно позначити анотацією @JsonSubTypes.
3. При серіалізацїї в YAML усім об'єктам списку animals потрібно додати тип і зберегти основний формат.
*/

public class Solution {
    public static void main(String[] args) throws JsonProcessingException {
        Zoo zoo = new Zoo();
        zoo.animals.add(new Zoo.Lion("Алекс", 5.5));
        zoo.animals.add(new Zoo.Penguin("Шкіпер", true, 8));
        zoo.animals.add(new Zoo.Penguin("Ковальскі", true, 7));
        zoo.animals.add(new Zoo.Penguin("Ріко", false, 6));
        zoo.animals.add(new Zoo.Penguin("Прапор", false, 5));

        String result = new YAMLMapper().writeValueAsString(zoo);

        System.out.println(result);
    }
}

/**
 * Щоб досягти бажаного результату в серіалізації до формату YAML і додати тип для кожного елементу списку animals,
 * потрібно додати деякі анотації від Jackson до вашого класу Animal та його підкласів.
 *
 * Ось підказки, як це зробити:
 *
 * 1. @JsonTypeInfo: Ця анотація вказує на те, що ми хочемо додати додаткову інформацію про тип при серіалізації.
 * Вам потрібно вказати два атрибути для цієї анотації:
 *
 * use: як ви хочете вказувати тип (зазвичай це JsonTypeInfo.Id.NAME).
 * include: де ви хочете розмістити цю інформацію про тип в результаті (зазвичай це JsonTypeInfo.As.PROPERTY).
 *
 * 2. @JsonSubTypes: Ця анотація вказує на те, які підкласи існують для класу Animal та які назви типів вам потрібно
 * використовувати для кожного підкласу. Ви повинні додати @JsonSubTypes.Type для кожного підкласу, вказавши клас
 * і ім'я, яке ви хочете використовувати для цього типу в результаті.
 *
 * 3. Приклад для класу Lion: Щоб вказати, що Lion повинен мати ім'я типу "lion" при серіалізації, вам потрібно додати
 * такий елемент до анотації @JsonSubTypes: @JsonSubTypes.Type(value = Lion.class, name = "lion").
 *
 * 4. Застосуйте аналогічний підхід для класу Penguin.
 *
 * Коли ви правильно додасте ці анотації до вашого класу Animal, ви зможете серіалізувати об'єкти Zoo так, що кожний
 * елемент списку animals буде мати додаткову властивість, що вказує його тип (наприклад, "lion" або "penguin").
 *
 *
 * Анотація @JsonTypeInfo використовується для вказівки додаткової інформації про тип об'єкта під час його серіалізації
 * або десеріалізації.
 *
 * use = JsonTypeInfo.Id.NAME:
 *
 * use вказує на те, як інформація про тип повинна бути представлена.
 * JsonTypeInfo.Id.NAME означає, що для представлення типу буде використовуватися строкове ім'я, яке вказане в анотації
 * @JsonSubTypes.Type. Наприклад, в нашому випадку це "lion" для класу Lion та "penguin" для класу Penguin.
 * include = JsonTypeInfo.As.PROPERTY:
 *
 * include вказує, де інформація про тип повинна з'явитися в результаті серіалізації.
 * JsonTypeInfo.As.PROPERTY означає, що інформація про тип буде додана як звичайне поле (властивість) об'єкта в JSON.
 * Ім'я цієї властивості за замовчуванням є "@type", але його можна змінити, вказавши параметр property в @JsonTypeInfo.
 * У вашому прикладі це не було вказано, але я додав property = "type", щоб явно вказати, що ім'я поля в JSON повинно бути "type".
 * Отже, коли ви серіалізуєте об'єкт Lion або Penguin, в результаті буде додане поле "type" з відповідним значенням
 * "lion" або "penguin" для вказівки на конкретний тип об'єкта.
 *
 * Анотація @JsonSubTypes використовується разом з @JsonTypeInfo для вказівки конкретних підтипів об'єкта і їх строкових
 * імен (які будуть використовуватися в JSON представленні) для цих підтипів.
 *
 * Давайте розглянемо кожний компонент анотації:
 *
 * @JsonSubTypes.Type - це анотація, що вказує на підтип та його строкове ім'я для серіалізації/десеріалізації.
 *
 * value = Lion.class - це конкретний підтип, який ми хочемо асоціювати з ім'ям, вказаним в параметрі name.
 *
 * name = "lion" - це строкове ім'я, яке буде використовуватися в JSON для представлення об'єкта типу Lion.
 *
 * Аналогічно, value = Penguin.class і name = "penguin" асоціюють клас Penguin зі строковим ім'ям "penguin".
 *
 * Коли ми групуємо кілька @JsonSubTypes.Type разом, ми використовуємо фігурні дужки {}. У вашому випадку, ви маєте два
 * підтипи - Lion і Penguin, і обидва цих підтипи вказані в @JsonSubTypes.
 *
 * Отже, що відбувається в результаті:
 *
 * Коли ви серіалізуєте об'єкт типу Lion до JSON, він буде містити поле (зазвичай "@type" або інше, якщо ви його зміните
 * в @JsonTypeInfo), яке буде мати значення "lion".
 * Аналогічно, коли ви серіалізуєте об'єкт типу Penguin, він буде містити це ж поле із значенням "penguin".
 * Під час десеріалізації, це поле буде використовуватися для визначення конкретного підтипу об'єкта, який потрібно створити.
 * */
