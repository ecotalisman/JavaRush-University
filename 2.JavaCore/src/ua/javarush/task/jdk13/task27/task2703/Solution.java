package ua.javarush.task.jdk13.task27.task2703;

/* 
Другий варіант deadlock
У методі secondMethod розстав synchronized блоки таким чином, щоб при використанні класу Solution потоками з'являвся deadlock.

Requirements:
1. У методі secondMethod має бути синхронізований блок по об'єкту lock.
2. У методі secondMethod має бути вкладений синхронізований блок по об'єкту this.
3. Поле lock має бути приватним.
4. Метод secondMethod не має бути оголошений з модифікатором synchronized.
*/

public class Solution {
    private final Object lock = new Object();

    public synchronized void firstMethod() {
        synchronized (lock) {
            doSomething();
        }
    }

    public void secondMethod() {
        // It was a condition:
//        doSomething();

        synchronized (lock) {
            synchronized (this) {
                doSomething();
            }
        }
    }

    private void doSomething() {
    }

    public static void main(String[] args) {
        // Test to create deadlock

//        Solution solution = new Solution();
//        new Thread(solution::firstMethod).start();
//        new Thread(solution::secondMethod).start();
    }
}

/*

Задача вимагає створити умови для deadlock (мертвої блокади). Для цього нам потрібно реорганізувати synchronized блоки
так, щоб два потоки спробували одночасно захопити два різних ресурси, але в зворотному порядку.

Ось як це можна зробити:

1. У firstMethod, який вже синхронізований за допомогою this, використовуйте вкладений synchronized блок, щоб
синхронізувати lock.

2. У secondMethod спочатку синхронізуйте lock, а потім вкладений synchronized блок для this.

Якщо ви запустите main, ви побачите, що програма блокується (мертва блокада). Це тому, що перший потік викликає
firstMethod і блокується на this, а потім намагається заблокувати lock. Тим часом другий потік викликає secondMethod,
блокується на lock, а потім намагається заблокувати this. Обидва потоки чекають одне на одного, що і є мертвою блокадою.

****************************************************************************************************************************

1) Як працює synchronized для методу secondMethod?

У методі secondMethod використовуються два вкладених synchronized блоки. Перший блок синхронізується на lock,
тобто потік, який виконує цей блок, має захопити монітор (або блокування) об'єкта lock. Другий вкладений блок
синхронізується на this, тобто потік, який виконує цей блок, має захопити монітор (або блокування) поточного
об'єкта Solution.

2) Як це synchronized в synchronized?

Вкладені synchronized блоки дозволяють потоку захопити декілька моніторів одночасно. Це не є проблемою само по собі,
проте це може стати причиною проблем, якщо інші потоки також намагаються захопити ці ж самі монітори, але в іншому
порядку, що призводить до взаємної блокади (deadlock).

3) Як відбувається deadlock?

Для того щоб пояснити як стається deadlock, спробуймо детальніше розглянути послідовність дій:

Перший потік викликає firstMethod і блокується на this (через модифікатор synchronized методу). Після цього він
намагається захопити блокування на lock, але може заблокуватися, якщо lock вже захоплений іншим потоком.

Другий потік викликає secondMethod і намагається захопити блокування на lock. Якщо він це робить, то наступний крок
для нього - спробувати захопити блокування на this.

При цьому сценарію можливий deadlock в такому порядку:

3.1 Перший потік захоплює блокування на this.
3.2 Другий потік захоплює блокування на lock.
3.3 Перший потік намагається захопити блокування на lock, але не може цього зробити, тому що його вже захопив
другий потік. Тому перший потік чекає.

3.4 Другий потік намагається захопити блокування на this, але не може цього зробити, тому що його вже захопив
перший потік. Тому другий потік також чекає.

Обидва потоки чекають одне на одного, і це є deadlock.

4) Чому deadlock може не відбуватися при кожному запуску main?

Deadlock - це гонка умов, і це означає, що він може не завжди виникати. Залежно від того, як операційна система
планує потоки, один потік може встигнути виконати обидва synchronized блоки перед тим, як інший потік почне виконувати
свої. Це означає, що deadlock може бути непостійним і не завжди відтворюваним. Щоб побачити deadlock у дії, можливо,
вам доведеться запустити код декілька разів.

*/