package ua.javarush.task.jdk13.task21.task2103;

import java.util.Date;

/* 
Помилка в equals/hashCode
Виправ помилки реалізацій методів equals та hashCode для класу Solution.

Requirements:
1. Хешкоди однакових об'єктів мають бути рівними.
2. Метод equals повинен перевіряти, чи об'єкт, що передається, дорівнює поточному об'єкту (порівняння через ==).
3. Метод equals повинен перевіряти, чи об'єкт, що передається, є об'єктом класу Solution.
4. Метод equals повинен перевіряти значення всіх полів у об'єкта, що передається, і в поточного (зауваж, що деякі з
них можуть бути null).
5. Потрібно забезпечити коректну поведінку HashSet з типом елементів Solution.
6. У класів Solution потрібно реалізувати метод hashCode.
*/

public class Solution {
    private int anInt;
    private String string;
    private double aDouble;
    private Date date;
    private Solution solution;

    public Solution(int anInt, String string, double aDouble, Date date, Solution solution) {
        this.anInt = anInt;
        this.string = string;
        this.aDouble = aDouble;
        this.date = date;
        this.solution = solution;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        // Change code here:
        if (!(o instanceof Solution)) {
            return false;
        }

        Solution solution1 = (Solution) o;

        if (Double.compare(solution1.aDouble, aDouble) != 0) {
            return false;
        }
        if (anInt != solution1.anInt) {
            return false;
        }

        // Change code here:
        if (date != null ? !date.equals(solution1.date) : solution1.date != null) {
            return false;
        }
        if (solution != null ? !solution.equals(solution1.solution) : solution1.solution != null) {
            return false;
        }
        return string != null ? string.equals(solution1.string) : solution1.string == null;

        // It was a condition:
//        if (o instanceof Solution) {
//            return false;
//        }
//        if (date != null ? !date.equals(solution1.date) : solution1.date == null) {
//            return false;
//        }
//        if (solution != null ? !solution.equals(solution1.solution) : solution1.solution == null) {
//            return false;
//        }
//        if (string != null ? !string.equals(solution1.string) : solution1.string == null) {
//            return false;
//        }
//        return true;
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        result = anInt;
        temp = aDouble != +0.0d ? Double.doubleToLongBits(aDouble) : 0L;
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (solution != null ? solution.hashCode() : 0);

        // Add code here:
        result = 31 * result + (date != null ? date.hashCode() : 0);
        result = 31 * result + (string != null ? string.hashCode() : 0);
        return result;
    }

    public static void main(String[] args) {

    }
}

/*

temp = aDouble != +0.0d ? Double.doubleToLongBits(aDouble) : 0L;

використовується для обробки специфічного випадку, коли aDouble є 0.0d. Тут Double.doubleToLongBits(aDouble) повертає
різні значення для +0.0d та -0.0d, хоча відповідно до стандарту IEEE 754 вони повинні бути рівними.

Відповідно до специфікації методу equals() для класу Double, +0.0d та -0.0d вважаються рівними, і зважаючи на це,
ми маємо врахувати цей випадок при обчисленні хеш-коду.

****************************************************************************************************************************

temp = aDouble != +0.0d ? Double.doubleToLongBits(aDouble) : 0L;

+0.0d та -0.0d: У мові Java, тип даних double має два представлення нуля: позитивний нуль (+0.0) та
негативний нуль (-0.0). Це пов'язано із стандартом IEEE 754, який визначає представлення чисел з плаваючою комою в
комп'ютерних системах.

Double.doubleToLongBits(aDouble): цей метод мови Java конвертує значення double у відповідне двійкове
представлення (long), яке відповідає стандарту IEEE 754. Це включає спеціальні значення, такі як NaN (не число),
Infinity і -Infinity.

0L: Це представлення long типу нуля в Java. L вказує, що це значення long, а не int.

IEEE 754: Це стандарт, прийнятий Institute of Electrical and Electronics Engineers (IEEE), який визначає формати чисел
з плаваючою комою для комп'ютерних систем. Він описує представлення чисел з плаваючою комою, включаючи спеціальні
значення (наприклад, NaN, Infinity, -Infinity, +0.0 і -0.0), правила округлення, операції з числами та багато іншого.

****************************************************************************************************************************

temp = aDouble != +0.0d ? Double.doubleToLongBits(aDouble) : 0L;

Даний код є частиною алгоритму генерації хеш-коду. Цей рядок коду реалізує частину алгоритму, яка включає використання
числа 31 як основи та бітове зсування для генерації більш "розрідженого" набору значень хеш-коду. Давайте розберемо
це детальніше:

1:
temp ^ (temp >>> 32): Оператор ^ - це бітова операція XOR (виключне АБО). temp >>> 32 - це беззнакове бітове
зсування вправо на 32 біти (заповнює високі біти нулями). Результатом цієї операції є XOR значень temp і temp,
зсунутих на 32 біти вправо.

2:
(int) (temp ^ (temp >>> 32)): Тут ми конвертуємо результат бітових операцій до типу int. Зауважте, що temp є значенням
типу long, тому виконується звуження типу.

3:
31 * result: Число 31 тут використовується як основа для генерації хеш-коду. Вибір числа 31 є стандартною практикою
при генерації хеш-коду, оскільки воно є непарним простим числом, і використання таких чисел допомагає змінити
розподіл хеш-коду.

4:
result = 31 * result + (int) (temp ^ (temp >>> 32)): Тут ми оновлюємо result, додаючи до 31 * result результат бітових
операцій. Це означає, що result стає сумою попереднього значення result, помноженого на 31, та результату бітових
операцій, який був сконвертований до int.

Цей підхід використовується для створення хеш-коду, який має велику варіативність, що забезпечує краще розподіл
значень в хеш-таблицях.

****************************************************************************************************************************

temp ^ (temp >>> 32)

розглянемо на прикладі бітового зсуву вправо. В якості довільного числа я оберу число 16. В десятковій системі
числення це 16, а в двійковій - 10000.

Виконуючи беззнаковий бітовий зсув вправо на один біт (>>> 1), ми отримаємо наступний результат:
10000 (16 в двійковій системі) >>> 1 = 1000 (8 в двійковій системі)

Якщо ми виконаємо беззнаковий бітовий зсув вправо на два біти (>>> 2), ми отримаємо:
10000 (16 в двійковій системі) >>> 2 = 100 (4 в двійковій системі)

І так далі. Кожна ітерація зсуву вправо ділить число на 2 (в десятковій системі числення).

Проте у нашому початковому прикладі ми зсували на 32 біти. Зверніть увагу, що для 32-бітного числа такий зсув зведе
число до 0, оскільки він зсуває усі біти за межі 32-бітного числа.

Якщо ми говоримо про 64-бітне число (тип long в Java), то зсув на 32 біти вправо змістить старші 32 біти числа в
молодші 32 біти, а молодші 32 біти будуть заповнені нулями.

Приклад з 64-бітним числом:
1000000000000000000000000000000000000000000000000000000000000000 (2^63) >>> 32
= 10000000000000000000000000000000 (2^31)

Як бачимо, у нашому числі зсунуто 32 біта вправо, а всі молодші біти заповнено нулями.

****************************************************************************************************************************

temp ^ (temp >>> 32): Оператор ^ - це бітова операція XOR (виключне АБО). temp >>> 32 - це беззнакове бітове
зсування вправо на 32 біти (заповнює високі біти нулями). Результатом цієї операції є XOR значень temp і temp,
зсунутих на 32 біти вправо.

Операція XOR (виключне АБО) порівнює біти двох чисел і повертає 1 там, де вони відрізняються, і 0 - де вони однакові.

Щодо нашого прикладу з числом 16, необхідно зауважити, що це 32-бітне ціле число в Java. Тобто, його бітове
представлення буде виглядати так:
00000000000000000000000000010000

Якщо ми виконаємо операцію temp >>> 32, це в результаті дасть нам число 0, оскільки всі біти зсунуто за
межі 32-бітного числа.
00000000000000000000000000010000 >>> 32 = 00000000000000000000000000000000

Тепер, коли ми виконуємо операцію XOR між оригінальним числом і результатом зсуву, ми отримаємо саме оригінальне число,
оскільки XOR між будь-яким числом і 0 завжди дорівнює оригінальному числу:
00000000000000000000000000010000 XOR 00000000000000000000000000000000 = 00000000000000000000000000010000

Отже, для цілого числа, такого як 16, temp ^ (temp >>> 32) дорівнює самому числу.

Цей підхід може виглядати дещо заплутаним для цілих чисел, але його основна мета - розподілити біти числа double
(що перетворюється на long за допомогою Double.doubleToLongBits) по всій довжині хеш-коду, незалежно від того, в
якій частині 64-бітного числа вони знаходяться.

Коли ми проводимо бітову операцію XOR між числом і 0, ми отримуємо саме оригінальне число. Це тому, що XOR повертає 1,
коли біти відрізняються, та 0, коли вони однакові.

В нашому випадку, кожен біт числа 16 (00000000000000000000000000010000) відрізняється від відповідного біту
числа 0 (00000000000000000000000000000000).

Тому результатом XOR операції є саме число 16 (00000000000000000000000000010000).

При перетворенні цього двійкового числа назад до десяткового, ми дійсно отримуємо число 16.

****************************************************************************************************************************

if (date != null ? !date.equals(solution1.date) : solution1.date != null) {
            return false;
        }

Даний код використовує тернарний оператор ? :, який виконує одну з двох операцій в залежності від результату
логічного виразу.

Тут ми перевіряємо, чи дорівнює date null.

***
Якщо date не дорівнює null, ми порівнюємо його з solution1.date за допомогою метода equals(). Якщо ці два об'єкти
не дорівнюють одне одному (!date.equals(solution1.date) повертає true), ми повертаємо false з метода equals().
Це означає, що об'єкти не дорівнюють одне одному.

***
Якщо date дорівнює null, ми перевіряємо, чи solution1.date не дорівнює null. Якщо solution1.date не дорівнює null,
ми повертаємо false з метода equals(). Це означає, що один об'єкт має null для поля date, а інший - ні, тому вони
не можуть бути рівними.

Цей код використовується для перевірки рівності полів date в двох об'єктах, враховуючи можливість, що це поле
може бути null.



































*/