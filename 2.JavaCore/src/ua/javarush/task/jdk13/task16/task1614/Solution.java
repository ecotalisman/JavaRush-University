package ua.javarush.task.jdk13.task16.task1614;

/* 
Виведення стек-трейсу
1. Створити таск (public static клас SpecialThread, який реалізує інтерфейс Runnable).
2. SpecialThread має виводити в консолі свій стек-трейс.

Підказка: main thread вже виводить у консолі свій стек-трейс.

Requirements:
1. Додай до класу Solution публічний статичний клас SpecialThread.
2. Клас SpecialThread не має бути успадкований від якогось додаткового класу.
3. Клас SpecialThread має реалізувати інтерфейс Runnable.
4. Метод run класу SpecialThread повинен виводити свій стек-трейс.
*/

import java.util.Arrays;

public class Solution {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new SpecialThread());
        thread.start();

        System.out.println("*****************");

        for (StackTraceElement element : Thread.currentThread().getStackTrace()) {
            System.out.println(element);
        }
    }

    public static class SpecialThread implements Runnable {
        @Override
        public void run() {
            Arrays.stream(Thread.currentThread().getStackTrace())
                    .forEach(System.out::println);
        }
    }
}

/*

1:
Метод Arrays.stream() є статичним методом, який приймає масив як аргумент і повертає послідовність елементів масиву
у вигляді потоку (Stream).

Потік (Stream) в Java - це нова абстракція, що була введена в Java 8. Він дозволяє обробляти дані в декларативному стилі,
а не імперативному, як це зазвичай робиться в Java. Потоки роблять код більш читаблим та лаконічним, особливо при
роботі з колекціями або масивами даних.

Використовуючи потоки, ви можете застосовувати послідовність операцій до даних, таких як фільтрація,
перетворення (мапінг), редукція та інші.

У нашому конкретному випадку, Arrays.stream(Thread.currentThread().getStackTrace()) повертає потік об'єктів
StackTraceElement.

Цей потік потім передається методу forEach, який приймає лямбда-функцію як аргумент. Лямбда-функція
System.out::println виконується для кожного елемента потоку, виводячи кожен елемент стек-трейсу в консоль.

2:
Код створює новий потік, запускає його, а потім виводить стек-трейс поточного потоку (що є основним потоком).

Клас SpecialThread, який реалізує інтерфейс Runnable, в свою чергу, виводить власний стек-трейс коли його
метод run() виконується.

Тут важливо розуміти, що Thread.currentThread().getStackTrace() виводить стек-трейс потоку, в якому виконується цей код.
Тому, коли ми викликаємо цей метод в main(), ми отримуємо стек-трейс основного потоку. А коли ми викликаємо цей
метод в run(), ми отримуємо стек-трейс SpecialThread.

****************************************************************************************************************************
Декларативне та імперативне програмування - це два різних стилю написання програмного коду.

Імперативне програмування орієнтоване на "як" реалізувати задачу. Воно вказує комп'ютеру кроки, які він має виконати,
щоб добитися бажаного результату. Тобто ви даєте детальні інструкції. Це дуже наглядно при роботі з циклами або умовами.
Приклад імперативного стилю програмування:

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = new ArrayList<>();
for (Integer number : numbers) {
    if (number % 2 == 0) {
        evenNumbers.add(number);
    }
}
// evenNumbers тепер містить список парних чисел

Декларативне програмування орієнтоване на "що" вам потрібно отримати, а не "як" це реалізувати. Ви просто описуєте
результат, який хочете отримати, а деталі реалізації приховані.
Приклад декларативного стилю програмування:

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(number -> number % 2 == 0)
                                   .collect(Collectors.toList());
// evenNumbers тепер містить список парних чисел

У цьому прикладі ми просто описали, що нам потрібно - фільтрувати парні числа. "Як" це зробити - це деталі,
які приховані в методі filter та collect.

Хоча декларативний стиль може здаватися більш складним для новачків, він може зробити код більш читабільним та легшим
для розуміння, особливо при виконанні складних операцій.

*/